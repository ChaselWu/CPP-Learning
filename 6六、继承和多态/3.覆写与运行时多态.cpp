//1.多态
/*
    1）广义的多态：
        不同类型的实体/对象对于同一消息有不同的响应，就是oop中的多态性
    2）目前，多态性有两种表现方式：
        重载多态：重载函数
        子类型多态：不同对象调用同名重定义函数表现出不同的行为
*/

//2.联编
/*
    1）确定具有多态性的语句调用哪一个函数的过程
    2）静态联编：编译时确定调用哪个函数，如：函数重载
    3）动态联编：程序运行时才能确定调用哪个函数
        用动态联编实现的多态，也称运行时多态
    4）通过派生类对象访问同名函数：静态联编
       通过基类指针访问同名函数：静态联编
       通过基类指针或引用访问同名虚函数：动态联编
    5）判断调用的是哪个同名函数
       函数非虚：是啥调啥
       函数虚：不看指针看真对象，不看引用看真对象
*/

//3.实现运行时多态
/*
    1）静态联编的麻烦之处：
        想实现用print()调用toString()来输出多个子类对象的信息，需要重载多个print()函数
    2）实现运行时多态的两个要素：
        virtual function虚函数
        override覆写：在派生类中重定义一个虚函数
    3）手段：使用基类类型指针访问派生类对象，调用派生类同名虚函数
        实现原因：在运行时，会检查指针所指的对象类型，因此调用哪个同名虚函数不由指针类型决定，而
      由指针所指的实体类型决定。
    4）虚函数的传递性：
        基类定义了同名虚函数，则派生类中的同名函数自动变为虚函数
    5）虚函数的特点：
        虚函数表
        运行时联编
        比非虚函数开销大
*/

//4.override关键字显示声明覆写
/*
    1）C++11引入override标识符，指定一个虚函数覆写另一个虚函数
      void f() override{};
    2）作用：避免bug：
      签名不匹配报错
      非虚函数报错
*/

//5.final关键字显示声明禁止覆写
/*
    void f() final{};//最后一次覆写
*/