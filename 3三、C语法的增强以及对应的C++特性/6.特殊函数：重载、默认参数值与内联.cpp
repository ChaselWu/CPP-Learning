//1.变量的作用域
/*
    1)分类：
        a.全局变量的作用域为全局作用域
        b.局部变量的作用域为局部作用域，局部作用域又可分为：
            文件作用域、函数作用域、函数内部的块作用域
    2)同名覆盖与就近原则
        如果外部代码块预期内嵌代码有同名的变量，则就会产生同名覆盖现象。此时遵循就近原则判断哪个同名
      变量起作用。
    3)unary scope resulution一元作用域解析运算符
        局部变量名与全局变量名相同时，可使用::来访问全局变量
            //#include<iostream>
            //using std::cout;
            //using std::endl;
            //int v1=10;
            //int main(){
            //  int v1=20;
            //  cout<<v1<<endl;
            //  cout<<::v1<<endl;
            //  return 0;
            //}
*/

//2.重载函数
/*
    1)重载函数时同一个名字空间中存在多个具有相同名字的函数所构成的语法现象
    2)调用重载函数的语句，是由编译器在编译期确定的
    3)判断依据是：函数参数的类型、个数、次序
    4)若无法判断，则报告二义性错误
*/

//3.带有默认参数值的函数
/*
    1）函数可以指定默认值
    2）指定默认值时，要保证带有默认值的参数要位于函数参数列表的右侧
    3）调用函数时，如果不指定带有默认值的参数，则参数自动被赋为默认值
    4）函数重定义/声明时，不允许重定义默认参数
        //#include <iostream>
        //int add(int a, int b = 1);
        //int main() {
        //  int x = 18;
        //  int b{32};
        //  std::cout << add(x);
        //  std::cout << add(b, x);
        //  return 0;
        //}
        //int add(int a, int b) { return a + b; }

    5）需注意默认参数值与重载函数的同时使用容易导致更多的二义性问题

*/

//4.内联函数
/*
    1）普通函数的优缺点：
        易读易维护，但是调用时有开销
        {调用时：参数及部分CPU寄存器内容进栈，控制流跳转
         返回时：返回值及寄存器值出栈，控制流跳转
    2）内联函数
        目的：减少函数调用开销
        方法：代码插入到调用处
        结果：程序变大
    3）定义内联函数：
        声明和定义时，类型前面均加上inline关键字即可，不过内联函数的声明和定义一般一起写
            //#include<iostream>
            //inline int add(int, int);
            //inline int add(int a, int b) { return 0; }
*/

//4.inline关键字只是程序员堆编译器的一个请求，内联函数是否展开由编译器决定
















